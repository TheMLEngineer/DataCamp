

 Ref : 

np.random.choice()
In this exercise, you will be introduced to the np.random.choice() function. This is a remarkably useful function for simulations and you will be making extensive use of it later in the course. As a first step, let's try to understand the basics of this function. Using help(), figure out which of the following input parameters are not optional for the np.random.choice() function:


 A : 


a - input array




In [1]: help(np.random.choice)
Help on built-in function choice:

choice(...) method of mtrand.RandomState instance
    choice(a, size=None, replace=True, p=None)
    
    Generates a random sample from a given 1-D array
    
            .. versionadded:: 1.7.0
    
    Parameters
    -----------
    a : 1-D array-like or int
        If an ndarray, a random sample is generated from its elements.
        If an int, the random sample is generated as if a were np.arange(a)
    size : int or tuple of ints, optional
        Output shape.  If the given shape is, e.g., ``(m, n, k)``, then
        ``m * n * k`` samples are drawn.  Default is None, in which case a
        single value is returned.
    replace : boolean, optional
        Whether the sample is with or without replacement
    p : 1-D array-like, optional
        The probabilities associated with each entry in a.
        If not given the sample assumes a uniform distribution over all
        entries in a.
    
    Returns
    --------
    samples : single item or ndarray
        The generated random samples
    
    Raises
    -------
    ValueError
        If a is an int and less than zero, if a or p are not 1-dimensional,
        if a is an array-like of size 0, if p is not a vector of
        probabilities, if a and p have different lengths, or if
        replace=False and the sample size is greater than the population
        size
    
    See Also
    ---------
    randint, shuffle, permutation
    
    Examples
    ---------
    Generate a uniform random sample from np.arange(5) of size 3:
    
    >>> np.random.choice(5, 3)
    array([0, 3, 4])
    >>> #This is equivalent to np.random.randint(0,5,3)
    
    Generate a non-uniform random sample from np.arange(5) of size 3:
    
    >>> np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])
    array([3, 3, 0])
    
    Generate a uniform random sample from np.arange(5) of size 3 without
    replacement:
    
    >>> np.random.choice(5, 3, replace=False)
    array([3,1,0])
    >>> #This is equivalent to np.random.permutation(np.arange(5))[:3]
    
    Generate a non-uniform random sample from np.arange(5) of size
    3 without replacement:
    
    >>> np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])
    array([2, 3, 0])
    
    Any of the above can be repeated with an arbitrary array-like
    instead of just integers. For instance:
    
    >>> aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']
    >>> np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])
    array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'],
          dtype='|S11')

Great work! The np.random.choice() function will work even if you only provide the input array a. Make sure to make use of the help() function throughout the course, it will help get you through some tough exercises!

--------------------------------------------------------------------------------------------------------------------------------------------------------------------


 Ref : 



Poisson random variable
The numpy.random module also has a number of useful probability distributions for both discrete and continuous random variables. In this exercise, you will learn how to draw samples from a probability distribution.

In particular, you will draw samples from a very important discrete probability distribution, the Poisson distribution, which is typically used for modeling the average rate at which events occur.

Following the exercise, you should be able to apply these steps to any of the probability distributions found in numpy.random. In addition, you will also see how the sample mean changes as we draw more samples from a distribution.




 Q : 


Using np.random.poisson() draw samples from a Poisson distribution using lam (lambda) and size_1.
Repeat the above step, but this time use size_2.
For each of the above samples, calculate the absolute difference between their mean and lambda using np.mean() and abs().




# Initialize seed and parameters
np.random.seed(123) 
lam, size_1, size_2 = 5, 3, 1000  

# Draw samples & calculate absolute difference between lambda and sample mean
samples_1 = np.random.poisson(lam , size_1)
samples_2 = np.random.poisson(lam , size_2)
answer_1 = abs(np.mean(samples_1) - lam)
answer_2 = abs(np.mean(samples_2) - lam) 

print("|Lambda - sample mean| with {} samples is {} and with {} samples is {}. ".format(size_1, answer_1, size_2, answer_2))



<script.py> output:
    |Lambda - sample mean| with 3 samples is 0.33333333333333304 and with 1000 samples is 0.07699999999999996.



Great work! Why do you think the larger size gives us a better result?



--------------------------------------------------------------------------------------------------------------------------------------------------------------------


 Ref : 


Shuffling a deck of cards
Often times we are interested in randomizing the order of a set of items. Consider a game of cards where you first shuffle the deck of cards or a game of scrabble where the letters are first mixed in a bag. As the final exercise of this section, you will learn another useful function - np.random.shuffle(). This function allows you to randomly shuffle a sequence in place. At the end of this exercise, you will know how to shuffle a deck of cards or any sequence of items.

Examine deck_of_cards in the shell.




 Q : 



Use the np.random.shuffle() function to shuffle deck_of_cards.
Select the top three cards from this list by slicing.





# Shuffle the deck
np.random.shuffle(deck_of_cards)

# Print out the top three cards
card_choices_after_shuffle = deck_of_cards[0:3]
print(card_choices_after_shuffle)




In [1]: deck_of_cards
Out[1]: 
[('Heart', 0),
 ('Heart', 1),
 ('Heart', 2),
 ('Heart', 3),
 ('Heart', 4),
 ('Heart', 5),
 ('Heart', 6),
 ('Heart', 7),
 ('Heart', 8),
 ('Heart', 9),
 ('Heart', 10),
 ('Heart', 11),
 ('Heart', 12),
 ('Club', 0),
 ('Club', 1),
 ('Club', 2),
 ('Club', 3),
 ('Club', 4),
 ('Club', 5),
 ('Club', 6),
 ('Club', 7),
 ('Club', 8),
 ('Club', 9),
 ('Club', 10),
 ('Club', 11),
 ('Club', 12),
 ('Spade', 0),
 ('Spade', 1),
 ('Spade', 2),
 ('Spade', 3),
 ('Spade', 4),
 ('Spade', 5),
 ('Spade', 6),
 ('Spade', 7),
 ('Spade', 8),
 ('Spade', 9),
 ('Spade', 10),
 ('Spade', 11),
 ('Spade', 12),
 ('Diamond', 0),
 ('Diamond', 1),
 ('Diamond', 2),
 ('Diamond', 3),
 ('Diamond', 4),
 ('Diamond', 5),
 ('Diamond', 6),
 ('Diamond', 7),
 ('Diamond', 8),
 ('Diamond', 9),
 ('Diamond', 10),
 ('Diamond', 11),
 ('Diamond', 12)]

<script.py> output:
    [('Diamond', 9), ('Spade', 9), ('Spade', 4)]






Great work! What are some other cases where you can use np.random.shuffle()?




--------------------------------------------------------------------------------------------------------------------------------------------------------------------


 Ref : 



Throwing a fair die
Once you grasp the basics of designing a simulation, you can apply it to any system or process. Next, we will learn how each step is implemented using some basic examples.

As we have learned, simulation involves repeated random sampling. The first step then is to get one random sample. Once we have that, all we do is repeat the process multiple times. This exercise will focus on understanding how we get one random sample. We will study this in the context of throwing a fair six-sided die.

By the end of this exercise, you will be familiar with how to implement the first two steps of running a simulation - defining a random variable and assigning probabilities.

For the rest of the course, look to the IPython shell to find out what seed has been set.





 Q : 



Construct a six-sided die as a list of each of the possible outcomes and assign it to the variable die.
Define the probability of each of the six sides having an equal chance of showing up and assign it to the variable probabilities.
Finally, use np.random.choice() to simulate a single throw of the die and record its outcome in the outcome variable.



# Define die outcomes and probabilities
die, probabilities, throws = [1,2,3,4,5,6], [1/6,1/6,1/6,1/6,1/6,1/6], 1

# Use np.random.choice to throw the die once and record the outcome
outcome = np.random.choice(die, size=1, p=probabilities)
print("Outcome of the throw: {}".format(outcome[0]))



The seed for this exercise is set to 123

<script.py> output:
    Outcome of the throw: 5
	
	
Great work! What do you think will happen if the probabilities are not all the same?



--------------------------------------------------------------------------------------------------------------------------------------------------------------------

 Ref : 
 
 Throwing two fair dice
We now know how to implement the first two steps of a simulation. Now let's implement the next step - defining the relationship between random variables.

Often times, our simulation will involve not just one, but multiple random variables. Consider a game where throw you two dice and win if each die shows the same number. Here we have two random variables - the two dice - and a relationship between each of them - we win if they show the same number, lose if they don't. In reality, the relationship between random variables can be much more complex, especially when simulating things like weather patterns.

By the end of this exercise, you will be familiar with how to implement the third step of running a simulation - defining relationships between random variables.


 Q : 
 
 Set num_dice to 2.
Complete the np.random.choice() function to throw two dice and record the outcomes in the outcomes variable.
Fill in the Boolean condition to check if the two dice show the same number.




# Initialize number of dice, simulate & record outcome
die, probabilities, num_dice = [1,2,3,4,5,6], [1/6, 1/6, 1/6, 1/6, 1/6, 1/6], 2
outcomes = np.random.choice(die , size= 2 , p=probabilities) 

# Win if the two dice show the same number
if outcomes[0] == outcomes[1]: 
    answer = 'win' 
else:
    answer = 'lose'

print("The dice show {} and {}. You {}!".format(outcomes[0], outcomes[1], answer))





<script.py> output:
    The dice show 5 and 5. You win!
	


Great work! Now you know how to define relationships between multiple random variables



--------------------------------------------------------------------------------------------------------------------------------------------------------------------

 Ref : 
 
 Simulating the dice game
We now know how to implement the first three steps of a simulation. Now let's consider the next step - repeated random sampling.

Simulating an outcome once doesn't tell us much about how often we can expect to see that outcome. In the case of the dice game from the previous exercise, it's great that we won once. But suppose we want to see how many times we can expect to win if we played this game multiple times, we need to repeat the random sampling process many times. Repeating the process of random sampling is helpful to understand and visualize inherent uncertainty and deciding next steps.

Following this exercise, you will be familiar with implementing the fourth step of running a simulation - sampling repeatedly and generating outcomes.


 Q : 
 
 Set sims to 100 repetitions and initialize wins to 0.
Write a for loop to repeat throwing the dice.
Set outcomes to the outcome of throwing two dice.
If the two dice show the same number, increment wins by 1.





# Initialize model parameters & simulate dice throw
die, probabilities, num_dice = [1,2,3,4,5,6], [1/6, 1/6, 1/6, 1/6, 1/6, 1/6], 2
sims, wins = 100 , 0

for i in range(sims):
    outcomes = np.random.choice(die , size = 2 , p=probabilities) 
    # Increment `wins` by 1 if the dice show same number
    if outcomes[0] == outcomes[1]: 
        wins = wins + 1 

print("In {} games, you win {} times".format(sims, wins))





<script.py> output:
    In 100 games, you win 25 times
	


Great work! Now you know how to define relationships between multiple random variables



--------------------------------------------------------------------------------------------------------------------------------------------------------------------

 Ref : 
 
 Simulating one lottery drawing
In the last three exercises of this chapter, we will be bringing together everything you've learned so far. We will run a complete simulation, take a decision based on our observed outcomes, and learn to modify inputs to the simulation model.

We will use simulations to figure out whether or not we want to buy a lottery ticket. Suppose you have the opportunity to buy a lottery ticket which gives you a shot at a grand prize of $1 Million. Since there are 1000 tickets in total, your probability of winning is 1 in 1000. Each ticket costs $10. Let's use our understanding of basic simulations to first simulate one drawing of the lottery.


 Q : 
 
 Define chance_of_winning as the probability of winning the lottery.
Remember that 1 out of the total number of lottery tickets sold will win.
Set the probability list, which includes the probability of winning the lottery, as defined by chance_of_winning and its complement.
Use np.random.choice() to perform one simulation of this lottery drawing.




# Pre-defined constant variables
lottery_ticket_cost, num_tickets, grand_prize = 10, 1000, 1000000

# Probability of winning
chance_of_winning = 1/num_tickets

# Simulate a single drawing of the lottery
gains = [-lottery_ticket_cost, grand_prize-lottery_ticket_cost]
probability = [  1 - (chance_of_winning) , chance_of_winning]
outcome = np.random.choice(a=gains, size=1, p= probability , replace=True)

print("Outcome of one drawing of the lottery is {}".format(outcome))




<script.py> output:
    Outcome of one drawing of the lottery is [-10]
	

Great work! Now let's see how we can simulate multiple times.



--------------------------------------------------------------------------------------------------------------------------------------------------------------------

 Ref : 
 
 Should we buy?
In the last exercise, we simulated the random drawing of the lottery ticket once. In this exercise, we complete the simulation process by repeating the process multiple times.

Repeating the process gives us multiple outcomes. We can think of this as multiple universes where the same lottery drawing occurred. We can then determine the average winnings across all these universes. If the average winnings are greater than what we pay for the ticket then it makes sense to buy it, otherwise, we might not want to buy the ticket.

This is typically how simulations are used for evaluating business investments. After completing this exercise, you will have the basic tools required to use simulations for decision-making.


 Q : 
 
 Set the size parameter, which controls the number of simulations, to 2000.
Set payoffs equal to a list containing how much you could lose and how much you could win.
Set probs equal to a list of probabilities of losing and winning.
Calculate the mean of outcomes and assign it to answer.


# Initialize size and simulate outcome
lottery_ticket_cost, num_tickets, grand_prize = 10, 1000, 1000000
chance_of_winning = 1/num_tickets
size = 2000
payoffs = [10 , 1000000]
payoffs = [-lottery_ticket_cost, grand_prize-lottery_ticket_cost]
probs = [1 - (1 / num_tickets) , 1/num_tickets]

outcomes = np.random.choice(a=payoffs , size=size, p=probs, replace=True)

# Mean of outcomes.
answer = np.mean(outcomes)
print("Average payoff from {} simulations = {}".format(size, answer))




<script.py> output:
    Average payoff from 2000 simulations = 1990.0
	
	
	
Great work! Is it worth spending $10 on the ticket for this average payoff?



--------------------------------------------------------------------------------------------------------------------------------------------------------------------

 Ref : 
 
 Calculating a break-even lottery price
Simulations allow us to ask more nuanced questions that might not necessarily have an easy analytical solution. Rather than solving a complex mathematical formula, we directly get multiple sample outcomes. We can run experiments by modifying inputs and studying how those changes impact the system. For example, once we have a moderately reasonable model of global weather patterns, we could evaluate the impact of increased greenhouse gas emissions.

In the lottery example, we might want to know how expensive the ticket needs to be for it to not make sense to buy it. To understand this, we need to modify the ticket cost to see when the expected payoff is negative.

grand_prize, num_tickets, and chance_of_winning are loaded in the environment.




 Q : 
 
 Set sims to 3000 and the lottery_ticket_cost variable to 0.
Within the while loop, break if the mean value of outcomes falls below zero.
Otherwise, increment lottery_ticket_cost by 1.




# Initialize simulations and cost of ticket
sims, lottery_ticket_cost = 3000 , 0

# Use a while loop to increment `lottery_ticket_cost` till average value of outcomes falls below zero
while 1:
    outcomes = np.random.choice([-lottery_ticket_cost, grand_prize-lottery_ticket_cost],
                 size=sims, p=[1-chance_of_winning, chance_of_winning], replace=True)
    if outcomes.mean() < 0:
        break
    else:
        lottery_ticket_cost += 1
answer = lottery_ticket_cost - 1

print("The highest price at which it makes sense to buy the ticket is {}".format(answer))



The seed for this exercise is set to 333

<script.py> output:
    The highest price at which it makes sense to buy the ticket is 9
	
	


--------------------------------------------------------------------------------------------------------------------------------------------------------------------
























































































































