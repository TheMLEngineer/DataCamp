

 Ref : 



EDA: Plot ECDFs of active bout length
An active bout is a stretch of time where a fish is constantly moving. Plot an ECDF of active bout length for the mutant and wild type fish for the seventh night of their lives. The data sets are in the numpy arrays bout_lengths_wt and bout_lengths_mut. The bout lengths are in units of minutes.





 Q : 



Import the module dc_stat_think as dcst so you have its functions available.
Generate the x and y values for plotting the ECDF of the wild type fish (bout_lengths_wt) using dcst.ecdf(). Store the result in numpy arrays named x_wt and y_wt.
Do the same for the the mutant fish (bout_lengths_mut), storing the result in numpy arrays named x_mut and y_mut.
Use plt.plot() to plot the two ECDFs as dots on the same plot. Be sure to specify the keyword arguments marker='.' and linestyle='none'.
Show your plot using plt.show().






# Import the dc_stat_think module as dcst
import dc_stat_think as dcst

# Generate x and y values for plotting ECDFs
x_wt, y_wt = dcst.ecdf(bout_lengths_wt)
x_mut , y_mut = dcst.ecdf(bout_lengths_mut)

# Plot the ECDFs
_ = plt.plot(x_wt , y_wt, marker ='.', linestyle='none')
_ = plt.plot(x_mut , y_mut , marker ='.', linestyle='none')

# Make a legend, label axes, and show plot
_ = plt.legend(('wt', 'mut'))
_ = plt.xlabel('active bout length (min)')
_ = plt.ylabel('ECDF')
plt.show()






Great work! There is an outlier of one active bout for a mutant fish, and the ECDF exposes this clearly. It is important to know about, but we will not focus on it going forward, though.

(Coz in plot one mutant point was an outlier)


---------------------------------------------------------------------------------------------------------------------------------------------------------------------



 Q : 



 Interpreting ECDFs and the story
While a more detailed analysis of distributions is often warranted for careful analyses, you can already get a feel for the distributions and the story behind the data by eyeballing the ECDFs. Which of the following would be the most reasonable statement to make about how the active bout lengths are distributed and what kind of process might be behind exiting the active bout to rest?

If you need a refresher, here are videos from Statistical Thinking I about stories behind probability distributions.

Discrete Uniform and Binomial
Poisson processes and Poisson distribution
Normal distribution
Exponential Distribution


 Hints : 


The Poisson distribution is discrete, and bout length is continuous. Further, the story is not right either.



Think about what the Normal distribution CDF looks like; it has tails on both ends.


 A : 

 The bout lengths appear Exponentially distributed, which implies that exiting an active bout to rest is a Poisson process; the fish have no apparent memory about when they became active.




Yes! While not exactly Exponentially distributed, the ECDF has no left tail, and no discernible inflection point, which is very much like the Exponential CDF.






---------------------------------------------------------------------------------------------------------------------------------------------------------------------


 Ref : 



Parameter estimation: active bout length
Compute the mean active bout length for wild type and mutant, with 95% bootstrap confidence interval. The data sets are again available in the numpy arrays bout_lengths_wt and bout_lengths_mut. The dc_stat_think module has been imported as dcst.



 Q : 




Compute the mean active bout length for wild type and mutant using np.mean(). Store the results as mean_wt and mean_mut.
Draw 10,000 bootstrap replicates for each using dcst.draw_bs_reps(), storing the results as bs_reps_wt and bs_reps_mut.
Compute a 95% confidence interval from the bootstrap replicates using np.percentile(), storing the results as conf_int_wt and conf_int_mut.
Print the mean and confidence intervals to the screen.





# Compute mean active bout length
mean_wt = np.mean(bout_lengths_wt)
mean_mut = np.mean(bout_lengths_mut)

# Draw bootstrap replicates
bs_reps_wt = dcst.draw_bs_reps(bout_lengths_wt , np.mean , size=10000)
bs_reps_mut = dcst.draw_bs_reps(bout_lengths_mut , np.mean , size = 10000)

# Compute 95% confidence intervals
conf_int_wt = np.percentile (bs_reps_wt , [2.5 , 97.5])
conf_int_mut = np.percentile(bs_reps_mut , [2.5 , 97.5])

# Print the results
print("""
wt:  mean = {0:.3f} min., conf. int. = [{1:.1f}, {2:.1f}] min.
mut: mean = {3:.3f} min., conf. int. = [{4:.1f}, {5:.1f}] min.
""".format(mean_wt, *conf_int_wt, mean_mut, *conf_int_mut))





<script.py> output:
    
    wt:  mean = 3.874 min., conf. int. = [3.6, 4.1] min.
    mut: mean = 6.543 min., conf. int. = [6.1, 7.0] min.




Nicely done! The confidence intervals are quite separated. Nonetheless, we will proceed to perform hypothesis tests.




---------------------------------------------------------------------------------------------------------------------------------------------------------------------








































































